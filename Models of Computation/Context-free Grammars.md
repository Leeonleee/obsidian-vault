# Table of Contents

# Limitations of Regular Expressions
- Can't handle arbitrary nesting (), (()), etc
- The language of balanced parentheses is not regular

# Context Free Grammars
- Naturally describe the hierarchical structure of most programming languages
- A **grammar** is a set of rules which describes a language
	- The rules are used to **generate (derive)** strings by rewriting
	- The rules can be thought of as a recursive description of the set of strings
## Example
$$S\rightarrow aSb$$
$$S\rightarrow T$$
$$T\rightarrow c$$
- A grammar is made up of
	- **Variables** $S,T$
	- **Terminals (input symbols):** $a,b,c$
	- **Rules:** 3 in this example
	- **Start Variable:** $S$
- The arrow $\rightarrow$ can be read as "produced" or "rewrites to"
- To generate/derive a string:
	1. Write the start variable
	2. Repeat the following until no variables are written down:
		1. Pick a variable $X$ that is written down
		2. Pick a rule $X\rightarrow\dots$
		3. Replace $X$ with the right-hand side of that rule
	3. The string that remains is generated by the grammar

# Anatomy of a Context-Free Grammar
A context-free grammar $G$ consists of 4 items:
1. Variables $V$, aka non-terminals
	- $A,B,C$
2. Terminals $\Sigma$ (disjoin from $V$)
	- $a,b,c,\dots,0,1,2,\dots,+,-,(,),\cdots$
3. Rules $R$
	- $A\rightarrow u$ where $u$ is a string of variables and terminals
4. Start variable
	- usually $S$ or the first one listed
$$G=(V,\Sigma,R,S)$$

The set of strings over $\Sigma$ that are derived from the start variable is called the **language generated by $G$**
$$L(G)=\lbrace u\in\Sigma^*:S\xRightarrow + u\rbrace$$
- Also called the **language of $G$**
---
A variable can have many rules:
$$S\rightarrow aSb$$
$$S\rightarrow T$$

They can also be written together
$$S\rightarrow aSb | T$$

# Designing CFGs
## Tips
1. Variables generate substrings with similar properties
2. Think recursively
	- How can a string in the language be built from smaller strings in the language?

## Examples
Design a grammar that generates the language of binary strings that are palindromes
- **Think recursively**
	1. Base cases: $0,1,\epsilon$ are palindromes
	2. Recursive cases: if $u$ is a palindrome, $0u0$ and $1u$ are palindromes
$$S\rightarrow 0|1|\epsilon$$
$$S\rightarrow 0S0|1S1$$

Design a grammar that generates the language of binary strings with the same number of 0's and 1's
- Base case: $\epsilon$ has the same number of 0's and 1's
- Recursive case: if $u$ has the same number of 0's and 1's, and also $v$, then $0u1v$ and $1u0v$
$$S\rightarrow \epsilon$$
$$S\rightarrow 0S1S|1S0S$$

# Context-Free Languages
A language is **context-free** if it is generated by a CFG
## Facts
- The union of 2 CFL is also context-free
	- Just add a new rule $S\rightarrow S_1|S_2$ where $S_i$ is the start symbol of grammar $i$
- The concatenation of 2 CFL is also context-free
	- Just add a new rule $S\rightarrow S_1S_2$
- The star closure of a CFL is also context-free
	- Just add a new rule $S\rightarrow SS_1|\epsilon$
- This implies that every regular language is context-free

# Other Ways to Write CFGs
$$ S\rightarrow TS$$
$$T\rightarrow c|d$$

## Program syntax
```
statements: statement+
statement: compount_stmt | simple_stmt
```

## Document Description Definition
```
<!ELEMENT NEWSPAPER (ARTICLE+)>
<!ELEMENT ARTICLE (STORY | ADVERT)
```

# Parse Tree
$$S\rightarrow S-S|x|y|z$$
A parse tree of a string $w$ is a tree labeled by variables and te